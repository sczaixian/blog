
计划步骤
1. 模型以及关系定义
2. api 接口定义以及模拟测试
3. 实现业务逻辑
4. 测试方法编写
5. 测试部署 docker、docker-compose
6. 上线测试

数据库需要哪些：
mysql：用户信息、文章标题、作者、发布时间、分类、标签、评论内容、评论者等结构化数据
MongoDB：文章内容存储（支持富文本、Markdown等格式）、草稿：易于扩展，适合存储半结构化数据
redis：热门文章和排行榜缓存、页面片段缓存、登录状态管理、限流和频率控制、实时统计数据（如阅读量）
es：全文检索功能、复杂的文章搜索（按关键词、标签、分类等）、
图数据库：用户关系网络（关注/粉丝）、内容推荐系统
时序数据库：访问日志分析、系统性能监控、用户行为时间序列分析、流量统计和报表
对像存储数据库：图片、视频、静态资源、备份和归档：低成本存储大量非结构化数据



type Article struct {
	UserID     uint `json:"user_id" gorm:"index"`     // 作者id

	定义与User模型的关联关系 foreignkey:UserID 指定使用本结构体的UserID字段作为外键
    这是一个"属于(Belongs To)"关系，表示文章属于某个用户
    数据库层面：articles表有user_id字段存储用户ID
    ORM层面：通过User字段可以自动加载关联的用户对象
    使用时：article.User 会返回完整的用户对象
	User     User      `json:"user" gorm:"foreignkey:UserID"`         // 作者


	CategoryID uint `json:"category_id" gorm:"index"` // 分类id
	Category Category  `json:"category" gorm:"foreignkey:CategoryID"` // 分类


	Tags     []Tag     `gorm:"many2many:article_tags;"`               // 标签
	多对多关系，通过article_tags中间表关联Tag模型


	Comments []Comment `gorm:"foreignKey:ArticleID"`                  // 评论
    一对多关系，Comment模型中有ArticleID字段作为外键

	Likes    []Like    `gorm:"foreignKey:ArticleID"`                  // 点赞
	一对多关系，Like模型中有ArticleID字段作为外键
}

User (users table)
  |
  | (一对多)
  v
Article (articles table)
  |   \
  |    \ (多对多)
  |     v
  |    Tag (tags table) via article_tags
  |
  v (一对多)
Comment (comments table)



// 创建文章
article := Article{
    Title: "Go语言入门",
    Content: "...",
    UserID: 123, // 设置作者ID
}

// 查询文章并加载关联用户
db.Preload("User").First(&article, 1)
fmt.Println(article.User.Name) // 访问作者姓名

// 查询某用户的所有文章
var userArticles []Article
db.Where("user_id = ?", 123).Find(&userArticles)




user:
    post:
        /login
        /register
        /logout
        /avatar 头像
    put
        /password 设置密码
        /profile 修改信息


article：
    get:
        /articles  //文章列表
        /article/{id}
    put:
        /article/{id}  // 修改
    delete:
        /article/{id}  // 删除

    post:
        /article/{id}  // 发布

comment
    get：
        /article/{id}/comments  // 文章下所有评论

    post:
        /article/{id}/comments  // 添加评论
        /comment/{parent_id}/replay //回复评论

    delete:
        /comments/{id}  // 删除评论

tag:
    get:
        /tags  // 获取标签

category:
    get:
        /categories
    put/delete:
        /categories/id

like
    post/delete:
        /article/id/like

follow:
    get:
        /users/id/followers
        /users/id/following
    post/delete:
        /users/id/follow

notification:
    get:
        /notifications


docker 启动redis
docker run --name blog_redis -p 6379:6379 -v /home/sc/redis_data_files/data/:/data -v /home/sc/redis_data_files/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf



Gin 内置绑定方法 根据请求的 Content-Type 自动选择解析器（JSON/XML/Form 等
ShouldBind(&obj)：通用绑定，自动推断类型
ShouldBindJSON(&obj)：仅绑定 JSON 数据
ShouldBindXML(&obj)：绑定 XML 数据
ShouldBindQuery(&obj)：仅绑定 URL Query 参数（适用于 GET 请求）
ShouldBindYAML(&obj)：绑定 YAML 数据


手动获取数据:无需结构体
Form 数据：c.PostForm("name")、c.PostFormArray("ids")
Query 参数：c.Query("page")。
Header/Cookie：c.GetHeader("User-Agent")、c.Cookie("session")



gin.Context包含：
请求信息：
    Request 对象：c.Request *http.Request- 原始 HTTP 请求
    请求方法：c.Request.Method- GET/POST/PUT/DELETE 等
    请求路径：c.Request.URL.Path
    请求头：c.Request.Header
    查询参数：c.Query("name")- 获取 URL 查询参数
    表单数据：c.PostForm("name")- 获取表单数据
    路径参数：c.Param("id")- 获取路由参数
    请求体：c.ShouldBindJSON(&obj)- 绑定 JSON 请求体
响应：
    响应状态码：c.Status(200)
    响应头：c.Header("Key", "Value")
    响应数据：
        c.String(200, "text")- 返回文本
        c.JSON(200, obj)- 返回 JSON
        c.HTML(200, "template.html", data)- 返回 HTML
    重定向：c.Redirect(302, "/new-path")
中间件：
    Keys 存储：用于中间件间传递数据
        c.Set("key", value)- 存储数据
        c.Get("key")- 获取数据
    中止链：c.Abort()- 中止后续处理程序
    下一个处理程序：c.Next()- 调用下一个处理程序
其他信息：
    客户端IP：c.ClientIP()
    内容协商：
        c.NegotiateFormat(offers...)- 内容协商
        c.GetHeader("Accept")- 获取 Accept 头
    Cookie 操作：
        c.Cookie("name")- 获取 Cookie
        c.SetCookie("name", "value", maxAge, path, domain, secure, httpOnly)
    文件上传：c.FormFile("file")- 获取上传文件
    流式响应：c.Stream(func(w io.Writer) bool { ... })